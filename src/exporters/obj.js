import { THREE } from '../environment.js';

function toFixed(n) {
  // Compact float formatting to keep files smaller
  return Number.isFinite(n) ? (+n).toFixed(6).replace(/\.0+$/,'').replace(/(\.[0-9]*?)0+$/,'$1') : '0';
}

// Export an array of THREE.Mesh as a single OBJ string (geometry only)
export function exportOBJFromMeshes(meshes = []) {
  const lines = [
    '# OBJ file generated by box_make_lego',
  ];

  let vOffset = 0;
  let vtOffset = 0;
  let vnOffset = 0;

  const normalMatrix = new THREE.Matrix3();
  const tmp = new THREE.Vector3();

  for (let i = 0; i < meshes.length; i++) {
    const mesh = meshes[i];
    if (!mesh || !(mesh.isMesh) || !mesh.geometry) continue;

    // Ensure world matrices are up to date
    mesh.updateWorldMatrix(true, false);

    let geom = mesh.geometry;
    if (!geom.isBufferGeometry) continue;
    // Work on a non-indexed clone so we can write faces sequentially
    let g = geom.index ? geom.toNonIndexed() : geom.clone();

    // Transform vertices to world space
    g.applyMatrix4(mesh.matrixWorld);

    // Ensure normals exist, then transform to world space
    if (!g.getAttribute('normal')) {
      g.computeVertexNormals();
    }
    normalMatrix.getNormalMatrix(mesh.matrixWorld);
    const nAttr = g.getAttribute('normal');
    if (nAttr) {
      for (let j = 0; j < nAttr.count; j++) {
        tmp.set(nAttr.getX(j), nAttr.getY(j), nAttr.getZ(j)).applyMatrix3(normalMatrix).normalize();
        nAttr.setXYZ(j, tmp.x, tmp.y, tmp.z);
      }
    }

    const pAttr = g.getAttribute('position');
    const uvAttr = g.getAttribute('uv');
    const hasUV = !!uvAttr;
    const hasN = !!nAttr;
    if (!pAttr || pAttr.count === 0) continue;

    const name = mesh.name && String(mesh.name).trim() ? mesh.name : `Mesh_${i}`;
    lines.push(`o ${name}`);

    // v
    for (let j = 0; j < pAttr.count; j++) {
      lines.push(`v ${toFixed(pAttr.getX(j))} ${toFixed(pAttr.getY(j))} ${toFixed(pAttr.getZ(j))}`);
    }

    // vt
    if (hasUV) {
      for (let j = 0; j < uvAttr.count; j++) {
        lines.push(`vt ${toFixed(uvAttr.getX(j))} ${toFixed(uvAttr.getY(j))}`);
      }
    }

    // vn
    if (hasN) {
      for (let j = 0; j < nAttr.count; j++) {
        lines.push(`vn ${toFixed(nAttr.getX(j))} ${toFixed(nAttr.getY(j))} ${toFixed(nAttr.getZ(j))}`);
      }
    }

    // faces: each triplet becomes one f
    for (let j = 0; j < pAttr.count; j += 3) {
      const a = vOffset + j + 1;
      const b = vOffset + j + 2;
      const c = vOffset + j + 3;
      if (hasUV && hasN) {
        const au = vtOffset + j + 1, bu = vtOffset + j + 2, cu = vtOffset + j + 3;
        const an = vnOffset + j + 1, bn = vnOffset + j + 2, cn = vnOffset + j + 3;
        lines.push(`f ${a}/${au}/${an} ${b}/${bu}/${bn} ${c}/${cu}/${cn}`);
      } else if (hasUV) {
        const au = vtOffset + j + 1, bu = vtOffset + j + 2, cu = vtOffset + j + 3;
        lines.push(`f ${a}/${au} ${b}/${bu} ${c}/${cu}`);
      } else if (hasN) {
        const an = vnOffset + j + 1, bn = vnOffset + j + 2, cn = vnOffset + j + 3;
        lines.push(`f ${a}//${an} ${b}//${bn} ${c}//${cn}`);
      } else {
        lines.push(`f ${a} ${b} ${c}`);
      }
    }

    vOffset += pAttr.count;
    if (hasUV) vtOffset += uvAttr.count;
    if (hasN) vnOffset += nAttr.count;
  }

  return lines.join('\n') + '\n';
}

